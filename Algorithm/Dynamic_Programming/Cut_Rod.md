# 动态规划——钢条切割
## 问题描述
给定一段长度为n英寸的钢条和一个价格表pi（i=1,2,...,n），求切割钢条方案，使得销售收益rn最大。
## 算法原理
* 动态规划与分治方法很相似，都是通过组合子问题的解来求解原问题。动态规划算法通常用来求解最优化问题，常应用于子问题重叠的情况，即不同的子问题具有公共的子子问题，如果使用分治算法会大量重复求解公共子子问题，会浪费大量的时间，而动态规划算法对每个子子问题只求解一次，将其保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了不必要的计算工作。如果子问题的数量是输入规模的多项式函数，而我们可以在多项式时间内求解出每个子问题，那么动态规划方法的总运行时间就是多项式阶的。

## 伪代码实现
* CUT_ROD
* 钢条切割算法的最暴力求解方法，递归求解整个问题，由于重复求解子问题造成时间复杂度为指数级
```
CUT_ROD(p,n)
	if n==0
		return 0
	q=-1
	for i=1 to n
		q=max(q,p[i]+CUT_ROD(p,n-i))
	return q
	
```

--------------
* MEMORIZED\_CUT_ROD
* 钢条切割问题的动态规划解法——带备忘的自顶向下法，子问题的解会被记录在r[n]的数组中，当递归调用时先寻找有没有子问题的解，没有的时候再递归调用，如果有就直接使用子问题的解，避免了大规模的重复求解子问题，将时间复杂度降到多项式阶，在这里为O(n^2)
```
MEMORIZED_CUT_ROD(p,n)
	let r[0...n] be a new array
	for i=0 to n
		r[i]=-1
	return MEMORIZED_CUT_ROD_AUX(p,n,r)
```
```
MEMORIZED_CUT_ROD_AUX(p,n,r)
	if r[n]>=0
		return r[n]
	if n==0
		q=0
	else
		q=-1
		for i=1 to n
			q=max(q,p[i]+MEMORIZED_CUT_ROD_AUX(p,n-i,r))
	r[n]=q
	return q
```

---------------------
* BOTTOM\_UP\_CUT_ROD
* 钢条切割问题的动态规划解法——自底向上法，自底向上法需要恰当定义子问题的规模的概念，使得任何子问题的求解都只依赖与更小的子问题的求解。其时间复杂度也为多项式阶，在这里很明显为O(n^2)
```
BOTTOM_UP_CUT_ROD(p,n)
	let r[0...n] be a new array
	r[0]=0
	for j=1 to n
		q=-1
		for i=1 to j
			q=max(q,p[i]+r[j-i])
		r[j]=q
	return r[n]
```
